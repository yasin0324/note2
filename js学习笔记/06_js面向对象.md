# JavaScript的面向对象

---

JavaScript是支持多种编程范式的，包括函数式编程和面对对象编程

+ JavaScript中的对象被设计成一组**属性的无序集合**，像是一个哈希表，有key和value组成
+ **key是一个标识符名称，value可以是任意类型**，也可以是**其他对象或者函数类型**
+ 如果一个值**是一个函数**，那么我们可以称之为是**对象的方法**

> 如何创建一个对象？
>
> + 早期创建对象的方式最多的是使用Object类，并且使用new关键字来创建一个对象
>   + `var obj = new Object()`
>   + 这是因为早期很多JavaScript开发者是从Java过来的，他们更习惯于Java中通过new的方式创建一个对象
> + 后来很多开发者为了方便，直接通过字面量的形式来创建对象
>   + `var obj = { name: 'yasin' }`

# 对对象属性的操作

---

如果我们想要对**一个对象属性进行比较精准的操作控制**，我们可以使用**属性描述符**

+ 通过属性描述符**可以精准地添加或修改对象的属性**
+ 属性描述符需要使用`Object.defineProperty`来对属性进行添加或修改

## Object.defineProperty

`Object.defineProperty(obj, prop, descriptor)`

`Object.definProperty()`方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象

可接收三个参数：

+ `obj` 要定义属性的对象
+ `prop` 要定义或修改的属性的名称或`Symbol`
+ `descriptor` 要定义或修改的属性描述符

返回值：

+ 被传递给函数的对象

## 属性描述符

属性描述符的类型有两种：

+ **数据属性**（Data Properties）描述符（Descriptor）
+ **存取属性**（Accessor Properties）描述符（Descriptor）

|       | configurable | enumerable | value | writable | get | set |
| ----- | ------------ | ---------- | ----- | -------- | --- | --- |
| 数据描述符 | 可以           | 可以         | 可以    | 可以       | 不可以 | 不可以 |
| 存取描述符 | 可以           | 可以         | 不可以   | 不可以      | 可以  | 可以  |

## 数据属性描述符

+ `[[Configurable]]`（可配置的）：表示属性是否可以通过`delete`删除，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符
  + 当我们直接在一个对象上定义某个属性时，这个属性的`[[Configurable]]`为`true`
  + 当我们通过属性描述符定义一个属性时，这个属性的`[[Configurable]]`默认为`false`
+ `[[Enumerable]]`（可枚举的）：表示属性是否可以通过`for-in`或者`Object.keys()`返回该属性
  + 当我们直接在一个对象上定义某个属性时，这个属性的`[[Enumerable]]`为`true`
  + 当我们通过属性描述符定义一个属性时，这个属性的`[[Enumerable]]`默认为`false`
+ `[[Writable]]`（可修改/写的）：表示是否可以修改属性的值
  + 当我们直接在一个对象上定义某个属性时，这个属性的`[[Writable]]`为`true`
  + 当我们通过属性描述符定义一个属性时，这个属性的`[[Writable]]`默认为`false`
+ `[[value]]`：属性的`value`值，读取属性时会返回该值，修改属性时，会对其进行修改
  + 默认情况下这个值是`undefined`

```js
Object.defineProperty(obj, "name", {
  configurable: false,
  enumerable: false,
  writable: false,
  value: "yasin"
})
```

## 存取属性描述符

+ `[[Configurable]]`：表示属性是否可以通过`delete`删除，是否可以修改它的特性，或者是否可以将它修改为存取属性描述符
  + 当我们直接在一个对象上定义某个属性时，这个属性的`[[Configurable]]`为`true`
  + 当我们通过属性描述符定义一个属性时，这个属性的`[[Configurable]]`为默认`false`
+ `[[Enumerable]]`：表示属性是否可以通过`for-in`或者`Object.keys()`返回该属性
  + 当我们直接在一个对象上定义某个属性时，这个属性的`[[Enumerable]]`为`true`
  + 当我们通过属性描述符定义一个属性时，这个属性的`[[Enumerable]]`默认为`false`
+ `[[get]]`：获取属性时会执行的函数。默认为`undefined`
+ `[[set]]`：设置属性时会执行的函数。默认为`undefined`

```js
var obj = {
  name: "yasin"
}

// 对obj对象中的name添加描述符（存取属性描述符）
var _name = ""
Object.defineProperty(obj, "name", {
  configurable: true,
  enumerable: false,
  set: function(value) {
    console.log("set", value);
    _name = value;
  },
  get: function() {
    console.log("get");
    return _name;
  }
})

obj.name = "Sakura";
obj.name = "qizui";
obj.name = "lll";

console.log(obj.name);
```

## 同时定义多个属性

`Object.defineProperties()`方法直接在一个对象上定义多个新的属性或修改现有属性，并且返回该对象

```js
var obj = {
  name: "yasin",
  age: 22,
  height: 1.82
}

// Object.defineProperty(obj, "name", {});
// Object.defineProperty(obj, "age", {});
// Object.defineProperty(obj, "height", {});

Object.defineProperties(obj, {
  name: {
    configurable: true,
    enumerable: true,
    writable: false
  },
  age: {
  },
  height:{
  }
})
```

## 对象方法补充（了解即可）

+ 获取对象的属性描述符
  + `getOwnPropertyDescriptor`
  + `getOwnPropertyDescriptors`
+ 禁止对象扩展新属性
  + `preventExtensions`
  + 给一个对象添加新的属性会失败（严格模式下会报错）
+ 密封对象，不允许配置和删除属性
  + `seal`
  + 实际是调用`preventExtensions`，并将现有属性的`configurable:false`
+ 冻结对象，不允许修改现有属性
  + `freeze`
  + 实际上是调用`seal`，并将现有属性的`writable:false`

# 创建对象的方案

---

## 创建多个对象的方案

目前学习了两种方式

+ new Object方式
+ 字面量创建方式

> 但是这两种方法有很大的弊端：创建同样的对象时，需要编写重复的代码

## 创建对象的方案 - 工厂模式

+ 工厂模式其实是一种常见的设计模式
+ 通常会有一个工厂方法，通过该工厂方法我们可以产生想要的对象

```js
function createPerson(name, age, height, address) {
  var p = new Object();
  p.name = name;
  p.age = age;
  p.height = height;
  p.address = address;
  
  p.eating = function() {
    console.log(this.name + 'is eating...');
  }
  
  p.running = function() {
    console.log(this.name + 'is running...');
  }
  
  return p;
}

var p1 = createPerson('yasin', 21, 1.88, "WuHan");
var p2 = createPerson('Sakura', 21, 1.70, "WuHu");
var p3 = createPerson('iin', 21, 1.70, "WuHu");
```

## 认识构造函数

工厂模式创建对象有一个比较大的问题：我们在打印对象时，对象的类型都是Object类型

+ 但是从某些角度来说，这些对象应该有一个他们共同的类型
+ 下面来看另一种模式：构造函数的方式

什么是构造函数？

+ 构造函数也称之为构造器（constructor），通常是我们在创建对象时会调用的函数
+ 在其他面相对象的编程语言里，构造函数时存在于类中的一个方法，称之为构造函数
+ 但是JavaScript中的构造函数不太一样

JavaScript中的构造函数：

+ 构造函数也是一个普通的函数
+ 如果这么一个普通的函数被new操作符调用了，那么这个函数就称之为是一个构造函数

> 那被new调用有什么特殊的呢？

## new操作符调用的作用

如果一个函数被new操作符调用了，会执行如下操作：

1. 在内存中创建一个新的对象（空对象）
2. 这个对象内部的`[[prototype]]`属性会被赋值为该构造函数的`prototype`属性
3. 构造函数内部的this，会指向创建出来的新对象
4. 执行函数的内部代码（函数体代码）
5. 如果构造函数没有返回非空对象，则返回创建出来的新对象

```js
function Person() {
}

var p1 = new Person();
var p2 = new Person();

console.log(p1);	// Person {}
```

## 创建对象的方案-构造函数

```js
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
  
  this.eating = function() {
    console.log(this.name + 'is eating...');
  }
  
  this.running = function() {
    console.log(this.name + 'is running...')
  }
}
```

+ 这个构造函数可以确保我们的对象是有Person的类型的（实际是constructor的属性）
+ 构造函数也是有缺点的，它在于我们需要对每个对象的函数去创建一个函数对象实例
