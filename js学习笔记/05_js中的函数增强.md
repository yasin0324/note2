# arguments

---

`arguments`是一个对应于传递给函数的参数的**类数组(array-like)对象**

array-like意味着它**不是一个数组类型，而是一个对象类型**

+ 但是它却拥有数组的一些特性，比如说`length`，比如可以通过`index`索引来访问
+ 但是它却没有数组的一些方法，比如`filter`、`map`等

## arguments转Array

```js
// 方式一：遍历arguments，添加到一个新数组中
var newArguments = [];
for (var arg of arguments) {
  newArguments.push(arg);
}

// 方式二：调用数组slice函数的call方法
var newArgs = Array.prototype.slice.call(arguments);
// var newArgs = [].slice.call(arguments);

// 方式三：ES6+的方法
var newArgs = Array.from(arguments);
var newArgs = [...arguments];
```

## 箭头函数中没有arguments

箭头函数是不绑定arguments的，所以我们在箭头函数中使用arguments会去上层作用域查找

ES6之后更推荐使用剩余（rest）参数

+ 如果最后一个参数是`...`为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组
+ 那么剩余参数和`arguments`有什么区别呢？
  + 剩余参数只包含那些没有对应形参的实参，而`arguments`对象包含了传给函数的所有实参
  + `arguments`对象不是一个真正的数组，而`rest`参数是一个真正的数组，可以进行数组的所有操作
  + `arguments`是早期`ECMAScript`中为了方便去获取所有的参数所提供的一个数据结构，而`rest`参数是`ES6`中提供并且希望以此来替代`arguments`的
+ 剩余参数**必须放到最后一个位置**，否则会报错
  + 注意：**rest参数是不参与参数的个数的**

# JavaScript纯函数

---

**函数式编程**有一个非常重要的概念叫**纯函数**，JavaScript符合**函数式编程的范式**，所以也有**纯函数的概念**

## 纯函数的维基百科定义

> 在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数：

1. 次函数在相同的输入值时，需产生相同的输出
2. 函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关
3. 该函数不能有语义上可观察到函数副作用，诸如”触发事件“，使输出设备输出，或更改输出值以外物件的内容

> 简单总结一下：
>
> + 确定的输入，一定会产生确定的输出
> + 函数在执行过程中，不能产生副作用

## 副作用（side effect）的理解

+ 表示在**执行一个函数**时，处了**返回函数值**之外，还对调**用函数产生了附加的影响**，比如**修改了全局变量**，**修改参数或者改变外部的存储**
+ 纯函数在执行的过程中就是不能产生这样的副作用，副作用往往是产生**bug的“温床”**

## 纯函数的案例

我们来看两个对数组操作的函数：

+ `slice`：`slice`截取数组是不会对原数组进行任何操作，而是生成一个新的数组

+ `splice`：`splice`截取数组，会返回一个新的数组，也会对原数组进行修改

+ slice就是一个纯函数，不会修改传入的参数

  ```js
  var names = ["abc", "cba", "nba", "dna"];
  
  // slice截取数组时不会对原数组进行任何操作，而是生成一个新的数组
  var newNames = names.slice(0, 2);
  console.log(newNames);	// ["abc", "cba"]
  console.log(names);	// ["abc", "cba", "nba", "dna"]
  
  // splice截取数组，会返回一个新的数组，也会对原数组进行修改
  var newNames2 = names.splice(0, 2);
  console.log(newName2);	// ["abc", "cba"]
  console.log(names);	// ["nba", "dna"]
  ```

## 纯函数的作用和优势

为什么纯函数在函数式编程中非常重要呢？

+ 因为可以安心地编写和使用
+ 在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改
+ 在用的时候，确定输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出

# JavaScript柯里化

---

**柯里化**也属于**函数式编程**里面一个非常重要的概念

## 柯里化的维基百科解释

+ 在计算机科学中，柯里化（Currying），又译为卡瑞化或加里化

+ 是把接收**多个参数的函数**，变成**接收一个单一参数**（最初函数的第一个参数）的函数，并且**返回接受余下的参数**，而且**返回结果的新函数**的技术

+ 柯里化声称“**如果你固定某些参数，你将得到接受余下参数的一个函数**”

  > 简单总计一下：
  >
  > + 只**传递给函数一部分参数来调用**它，让它**返回一个函数去处理剩余的参数**
  > + **这个过程就称之为柯里化**

+ 柯里化是一种函数的转换，将一个函数从可调用的f(a,b,c)转换为可调用的f(a)(b)(c)

  + 柯里化不会调用函数，它只是对函数进行转换


## 

 