# 组件生命周期

#核心概念 #生命周期

React 组件从创建到销毁的整个过程被称为组件的生命周期。在生命周期的不同阶段，React 提供了对应的方法（生命周期钩子）让我们执行特定的操作。

## 生命周期概述

React 组件的生命周期分为三个主要阶段：

1. **挂载阶段（Mounting）**：组件被创建并插入 DOM
2. **更新阶段（Updating）**：组件重新渲染，更新 DOM
3. **卸载阶段（Unmounting）**：组件从 DOM 中移除

> 注意：生命周期方法主要应用于**类组件**。函数组件通过 Hooks（如`useEffect`）实现类似的功能。

## 挂载阶段

当组件实例被创建并插入 DOM 中时，这些生命周期方法会按照以下顺序调用：

1. **constructor()**
2. **static getDerivedStateFromProps()**
3. **render()**
4. **componentDidMount()**

### constructor()

构造函数，用于初始化组件状态和绑定方法：

```jsx
constructor(props) {
  super(props); // 必须先调用super(props)

  // 初始化状态
  this.state = {
    counter: 0
  };

  // 绑定事件处理函数
  this.handleClick = this.handleClick.bind(this);
}
```

使用场景：

-   初始化 state
-   绑定事件处理函数的 this
-   **不要**在 constructor 中调用 setState
-   **不要**在 constructor 中执行有副作用或订阅操作

### static getDerivedStateFromProps()

在 render 之前调用，返回一个对象来更新 state，或返回 null 表示不需要更新：

```jsx
static getDerivedStateFromProps(props, state) {
  // 返回一个对象来更新state
  if (props.currentId !== state.lastId) {
    return {
      data: props.data,
      lastId: props.currentId
    };
  }

  // 返回null表示不需要更新state
  return null;
}
```

使用场景：

-   根据 props 变化更新 state（极少用到）
-   替代已废弃的 componentWillReceiveProps
-   这是一个静态方法，不能访问 this

### render()

render 是类组件中唯一必须实现的方法，负责返回要渲染的内容：

```jsx
render() {
  // 可以返回React元素（通过JSX创建）
  return <div>{this.state.message}</div>;

  // 或返回数组和fragments
  return [
    <li key="A">First item</li>,
    <li key="B">Second item</li>
  ];

  // 或返回字符串或数字（渲染为文本节点）
  return 'Hello World';

  // 或返回null或false（不渲染任何内容）
  return null;
}
```

注意事项：

-   render 应该是纯函数
-   不要在 render 中修改组件状态
-   每次更新时都会调用 render

### componentDidMount()

组件挂载到 DOM 后立即调用：

```jsx
componentDidMount() {
  // 适合执行副作用操作
  this.fetchData();
  // 添加订阅
  this.timer = setInterval(() => this.tick(), 1000);
}

fetchData() {
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => this.setState({ data }));
}
```

使用场景：

-   发起网络请求
-   添加订阅
-   操作 DOM
-   设置定时器
-   初始化第三方库

## 更新阶段

当组件的 props 或 state 发生变化时，会触发更新。更新阶段的生命周期方法按以下顺序调用：

1. **static getDerivedStateFromProps()**
2. **shouldComponentUpdate()**
3. **render()**
4. **getSnapshotBeforeUpdate()**
5. **componentDidUpdate()**

### shouldComponentUpdate()

决定组件是否应该更新，默认返回 true：

```jsx
shouldComponentUpdate(nextProps, nextState) {
  // 仅当id发生变化时更新
  return this.props.id !== nextProps.id;

  // 或者进行浅层比较
  return this.state.count !== nextState.count;
}
```

使用场景：

-   性能优化，避免不必要的渲染
-   可以用 PureComponent 或 React.memo 替代

### getSnapshotBeforeUpdate()

在更新之前获取 DOM 信息：

```jsx
getSnapshotBeforeUpdate(prevProps, prevState) {
  // 获取更新前的滚动位置
  if (prevProps.list.length < this.props.list.length) {
    const scrollPane = this.listRef.current;
    return scrollPane.scrollHeight - scrollPane.scrollTop;
  }
  return null;
}
```

使用场景：

-   在 DOM 更新前获取一些信息（如滚动位置）
-   返回值会作为第三个参数传递给 componentDidUpdate

### componentDidUpdate()

组件更新后立即调用：

```jsx
componentDidUpdate(prevProps, prevState, snapshot) {
  // 仅在props变化时执行操作
  if (this.props.userId !== prevProps.userId) {
    this.fetchData(this.props.userId);
  }

  // 使用getSnapshotBeforeUpdate返回的值
  if (snapshot !== null) {
    const scrollPane = this.listRef.current;
    scrollPane.scrollTop = scrollPane.scrollHeight - snapshot;
  }
}
```

使用场景：

-   对比更新前后的 props 或 state
-   基于条件发起网络请求
-   操作 DOM
-   注意在此方法中调用 setState 必须包含在条件语句中，否则会导致无限循环

## 卸载阶段

当组件从 DOM 中移除时，会调用：

### componentWillUnmount()

```jsx
componentWillUnmount() {
  // 清除定时器
  clearInterval(this.timer);
  // 取消网络请求
  this.apiCall.cancel();
  // 移除事件监听
  window.removeEventListener('resize', this.handleResize);
  // 清除订阅
  this.subscription.unsubscribe();
}
```

使用场景：

-   清理定时器
-   取消网络请求
-   移除事件监听器
-   清除订阅
-   释放资源

## 错误处理

下面的生命周期方法在子组件发生错误时被调用：

### static getDerivedStateFromError()

```jsx
static getDerivedStateFromError(error) {
  // 更新state使下一次渲染显示备用UI
  return { hasError: true };
}
```

### componentDidCatch()

```jsx
componentDidCatch(error, info) {
  // 记录错误信息
  console.error("Error:", error);
  console.log("Component stack:", info.componentStack);
  // 上报错误
  logErrorToService(error, info);
}
```

## 生命周期流程图

```
挂载阶段:
constructor() → getDerivedStateFromProps() → render() → componentDidMount()

更新阶段:
getDerivedStateFromProps() → shouldComponentUpdate() → render() → getSnapshotBeforeUpdate() → componentDidUpdate()

卸载阶段:
componentWillUnmount()

错误处理:
getDerivedStateFromError() → componentDidCatch()
```

## 已废弃的生命周期方法

以下方法计划在未来的 React 版本中移除：

-   ~~componentWillMount~~
-   ~~componentWillReceiveProps~~
-   ~~componentWillUpdate~~

使用这些方法需要加上`UNSAFE_`前缀，如`UNSAFE_componentWillMount()`。

## 函数组件与 Hooks

函数组件没有生命周期方法，但可以使用 Hooks 实现类似的功能：

```jsx
import React, { useState, useEffect } from "react";

function ExampleComponent() {
    const [data, setData] = useState(null);

    // 相当于componentDidMount和componentDidUpdate
    useEffect(() => {
        // 获取数据
        fetchData().then((result) => setData(result));

        // 相当于componentWillUnmount
        return () => {
            // 清理工作
            console.log("组件卸载或更新前执行清理");
        };
    }, []); // 空依赖数组表示仅在挂载和卸载时执行

    return <div>{data ? JSON.stringify(data) : "加载中..."}</div>;
}
```

Hooks 与生命周期的对应关系：

-   `useEffect(fn, [])` ≈ componentDidMount + componentWillUnmount
-   `useEffect(fn)` ≈ componentDidMount + componentDidUpdate + componentWillUnmount
-   `useEffect(fn, [dep1, dep2])` ≈ 依赖变化时的 componentDidUpdate
-   `useLayoutEffect` ≈ componentDidMount + componentDidUpdate（但在浏览器绘制前同步执行）

## 相关概念

-   [[01-使用State|使用State]] - 组件状态管理
-   [[useEffect]] - 函数组件中处理副作用
-   [[错误边界]] - 捕获子组件渲染错误
