# 链表的定义

---

链表结构其实是内存内部的一种存储方式，链表则是阿保一系列节点串联起来，每个节点上至少包含两个部分：`数据域`与`指针域`

+ 数据：保存数据

+ 指针：指向下一个节点的引用

链表中的每个节点，通过指针域的值，形成一个线性结构

# 链表的优缺点

---

因为链表是一种`松散`的结构体，所以当想要找到其中的某一个节点时，只能够从`头结点`一级一级的往下找，但也因为这种松散的结构使得其进行`插入`和`删除`时只需要改变其`指针域`的指向即可

+ 优点：适合动态插入和删除的应用场景
+ 缺点：不能快速地定位和随机访问数据

# 数组和链表的对比总结

---

+ 数组和链表都是线性数据结构
+ 数组为静态结构，静态分配内存。链表支持动态分配内存
+ 数组在数据储存时是一段连续的内存空间，链表是非连续的通过指针来串联
+ 数组可以根据下标快速查找，链表则需要遍历查找
+ 数组在插入和删除时会有大量的数据移动补位，链表只需要改变指针指向

# js中链表的实现

---

不同于`new Array()`、`new Set()`、`new Map()`等数据结构，目前`js`官方还没有为我们提供一个直接的`链表API`实现。不过我们可以通过对象的方式去模拟出一个`链表`

> 链表可以分为三类：
>
> - 单向链表：线型数据结构，指针指向下一个节点，终点指向null
> - 双向链表：可以往前或者往后添加节点，指针指向前一个节点和后一个节点
> - 循环链表：循环链表的第一个节点指向最后一个节点，最后一个节点指向第一个节点（循环链表又可以划分为“单向循环链表”和“双向循环链表”）

```js
// 对象化链表的呈现
const obj = {
  data: 1,
  next: {
    data: 2,
    next: {
      data: 3,
      next: null,
    },
  },
};
```

## 链表的插入

当我们需要向链表中插入一个节点时，只需要将插入地方的`上一个节点`指向自己，并且将`当前节点`指向下一个节点就完成了

## 链表的删除

当我们想要删除链表中一个节点时，只需要将目标节点的`上一个节点`指向当前节点的`下一个节点`，并且将目标节点指向到`null`完成释放，就可以完成一个删除操作

## 实现一个单向链表

```js
class neNode {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// 实现一个单项链表
class singleLinkedList {
    constructor() {
        this.head = null;
    }

    // 添加节点
    add(data) {
        let node = new neNode(data);
        if (this.head === null) {
            this.head = node;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = node;
        }
    }

    // 插入节点
    insert(data, target) {
        let node = new neNode(data);
        let current = this.head;
        while (current.next) {
            if (current.data === target) {
                node.next = current.next;
                current.next = node;
                break;
            }
            current = current.next;
        }
    }

    // 查找节点
    find(data) {
        let current = this.head;
        while (current) {
            if (current.data === data) {
                return current;
            }
            current = current.next;
        }
        return null;
    }

    // 删除节点
    remove(data) {
        let current = this.head;
        let previous = null;
        while (current) {
            if (current.data === data) {
                if (previous === null) {
                    this.head = current.next;
                } else {
                    previous.next = current.next;
                }
                return true;
            }
            previous = current;
            current = current.next;
        }
        return false;
    }
}

const List = new singleLinkedList();
List.add(1);
List.add(2);
List.add(3);
List.insert(4, 2);

console.dir(List, { depth: null });
// singleLinkedList {
//   head: neNode {
//     data: 1,
//     next: neNode {
//       data: 2,
//       next: neNode { data: 4, next: neNode { data: 3, next: null } }
//    }
//  }
// }
```

 

  
