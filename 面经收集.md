# http和https的区别

---

## 基本概念

**HTTP**（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。简单来说就是一种发布和接收HTML页面的方法，被用于在Web浏览器和网站服务器之间传递信息

HTTP默认工作在TCP协议80端口，用户访问网站`http://`开头的都是标准HTTP服务

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息

**HTTPS**（HyperText Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私和完整性

HTTPS默认工作在TCP协议443端口。工作流程一般如下：

1. TCP三次同步握手
2. 客户端验证服务器数字证书
3. DH算法协商对称加密算法的密钥、hash算法的密钥
4. SSL安全加密隧道协商完成
5. 网站以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改

## HTTP和HTTPS的区别

+ HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题
+ HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输
+ HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输
+ 两者的默认端口不一样，HTTP默认端口号是80，而HTTPS默认端口号是443
+ HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

# 箭头函数和普通函数的区别

---

## 箭头函数比普通函数更简洁

+ 如果没有参数，直接写一个空括号即可

+ 如果只有一个参数，可以省去参数的括号

+ 如果有多个参数，用逗号分隔

+ 如果函数体的返回值只有一句，可以省略大括号

+ 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void，最常见的就是调用一个函数

  ```js
  let fn = () => void doseNotReturn();
  ```

## 箭头函数没有自己的this

+ 箭头函数不会创建自己的this，所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它定义时已经确定了，之后不会改变

## 箭头函数继承来的this指向永远不会改变

```js
var id = 'GLOBAL';
var obj = {
    id: 'OBJ',
    a: function() {
        console.log(this.id);
    },
    b: () => {
        console.log(this.id);
    }
};
obj.a();	// 'OBJ'
obj.b();	// 'GLOBAL'
new obj.a()	// undefined
new obj.b()	// Uncaught TypeError: obj.b is not a constructor
```

对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即使这个函数是作为对象obj的方法调用，this依旧指向Window对象

> 需要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中

## call()、apply()、bind()等方法不能改变箭头函数this的指向

```js
var id = 'GLOBAL';
let fun1 = () => {
    console.log(this.id);
};
fun1();					// 'GLOBAL'
fun1.call({id: 'OBJ'});		// 'GLOBAL'
fun1.apply({id: 'OBJ'});	// 'GLOBAL'
fun1.bind({id: 'OBJ'})();	// 'GLOBAL'
```

## 箭头函数不能作为构造函数使用

构造函数在new的步骤实际上第二步就是将函数中的this指向该对象，但是由于箭头函数没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用

## 箭头函数没有自己的arguments

箭头函数没有自己的arguments对象，在箭头函数中访问arguments实际上获得的是它外层函数的arguments值

## 箭头函数没有prototype

## 箭头函数不能用作Generator函数，不能使用yeild关键字

# TCP和UDP的区别

---

|              | UDP                                        | TCP                                                  |
| ------------ | ------------------------------------------ | ---------------------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                             |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                                     |
| 传输方式     | 面向报文                                   | 面向字节流                                           |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                           |
| 适用场景     | 适用于实时应用，例如视频会议、直播         | 适用于要求可靠传输的应用，例如文件传输               |

# GET和POST请求的区别

---

+ 应用场景：get请求是一个幂等的请求，一般get请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而post请求不是一个幂等的请求，一般用于对服务器资源产生影响的场景，比如注册用户这一类的操作
+ 是否缓存：因为应用场景的不同，浏览器一般会对get请求缓存，但很少对post请求缓存
+ 发送的报文格式：get请求的报文中实体部分为空，post请求的报文中实体部分一般为向服务器发送的数据
+ 安全性：get请求可以将请求的参数放入url中向服务器发送，这样的做法相对于post请求来说是不太安全的，因为请求的url会被保留在历史记录汇总
+ 请求长度：浏览器由于对url长度的限制，所以会影响get请求发送数据时的长度。这个限制是浏览器规定的，并不是RFC规定的
+ 参数类型：post的参数传递支持更多的数据类型

# JavaScript的数据类型

---

JavaScript中的基本数据类型可以分为两类：原始数据类型和引用数据类型

## 原始数据类型

原始数据类型的值是不可变的，并且是按值传递的，即变量存储的是实际的数据值

`String`、`Number`、`BigInt`、`Boolean`、`undefined`、`null`、`Symbol`

## 引用数据类型

引用数据类型的值是可变的，变量存储的是数据的引用地址，因此是按引用传递的

`Object`（包括`Array`、`Function`、`Date`、`RegExp`等）

+ Object：对象是由一组键值对组成的数据结构，用来存储各种类型的数据

  ```js
  let person = {
      name: 'John',
      age: 30
  };
  ```

+ Array：数据是一个有序的集合，可以存储多个值，支持按索引访问

  ```js
  let numbers = [1, 2, 3, 4, 5];
  ```

+ Function：函数也是一种对象，它是可以调用的代码块，通常用于封装代码逻辑

  ```js
  function greet(name) {
      return `Hello, ${name}!`;
  }
  ```

+ Date：表示日期和实践，提供了多种方法来处理时间

  ```js
  let today = new Date();
  ```

+ RegExp：用于处理文本模式匹配的对象，可以用来搜索和替换字符串

  ```js
  let regex = /ab+c/;
  ```

