# http和https的区别

---

## 基本概念

**HTTP**（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。简单来说就是一种发布和接收HTML页面的方法，被用于在Web浏览器和网站服务器之间传递信息

HTTP默认工作在TCP协议80端口，用户访问网站`http://`开头的都是标准HTTP服务

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息

**HTTPS**（HyperText Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私和完整性

HTTPS默认工作在TCP协议443端口。工作流程一般如下：

1. TCP三次同步握手
2. 客户端验证服务器数字证书
3. DH算法协商对称加密算法的密钥、hash算法的密钥
4. SSL安全加密隧道协商完成
5. 网站以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改

## HTTP和HTTPS的区别

+ HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题
+ HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输
+ HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输
+ 两者的默认端口不一样，HTTP默认端口号是80，而HTTPS默认端口号是443
+ HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

## HTTPS解决了HTTP的哪些问题

+ HTTP由于是明文传输，所以安全上存在以下三个风险：
  + 窃听风险，比如通信链路上可以获取通信内容，用户号容易没
  + 篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎
  + 冒充风险，比如冒充淘宝网站，用户钱容易没
+ HTTPS在HTTP与TCP层之间加入了SSL/TLS协议，可以很好地解决上述的风险：
  + 信息加密：交互信息无法被窃取
  + 校验机制：无法篡改通信内容，篡改了就不能正常显示
  + 身份证书：证明淘宝是真的淘宝网

> HTTPS是如何解决上面的三个风险的？
>
> + **混合加密**的方式实现信息的**机密性**，解决了窃听的风险
> + **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的‘指纹’，指纹用于校验数据的完整性，解决了篡改的风险
> + 将服务器公钥放入到**数字证书**中，解决了冒充的风险

### 混合加密

通过**混合加密**的方式可以保证信息的**机密性**，解决了窃听的风险

![20-混合加密](C:\Users\锅\Desktop\guo\八股\image\20-混合加密.webp)

HTTPS采用的是**对称加密**和**非对称加密**结合的**混合加密**方式：

+ 在通信建立前采用**非对称加密**的方式交换会话秘钥，后续就不再使用非对称加密
+ 在通信过程中全部使用**对称加密**的会话密钥的方式加密明文数据

采用**混合加密**的方式的原因：

+ **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换
+ **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢

### 摘要算法 + 数字签名

为了保证传输的内容不被篡改，我们需要对内容计算出一个**指纹**，然后同内容一起传输给对方

对方收到后，先是对内容也计算出一个**指纹**，然后跟发送方发送的指纹做一个比较，如果**指纹**相同，说明内容没有被篡改，否则就可以判断出内容被篡改了

在计算机里会用**摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的指纹，这个**哈希值是唯一的，且无法通过哈希值推导出内容**

![摘要算法](C:\Users\锅\Desktop\guo\八股\image\摘要算法.webp)

通过哈希算法可以确保内容不会被篡改，**但是并不能保证*内容+哈希值*不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**

为了避免这种情况，计算机里会用**非对称加密算法**来解决，共有两个密钥：

+ 一个是公钥，这个是可以公开给所有人的
+ 一个是私钥，这个必须由本人管理，不可泄露

这两个密钥是可以**双向加解密**的，比如可以用公钥加密内容，让后用私钥解密，也可以用私钥加密内容，公钥解密内容

流程的不同，意味着目的也不相同：

+ **公钥加密，私钥解密**，目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容
+ **私钥加密，公钥解密**，目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的

因为非对称加密的计算比较耗费性能，一般不会用非对称加密来加密实际的传输内容

所以非对称加密的用途主要在于**通过*私钥加密，公钥解密*的方式，来确认消息的身份**，常说的**数字签名算法**，就是用的这种方式，不过私钥加密内容不是本身，而是**对内容的哈希值加密**

![数字签名](C:\Users\锅\Desktop\guo\八股\image\数字签名.webp)

私钥由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的

### 数字证书

![22-数字证书工作流程](C:\Users\锅\Desktop\guo\八股\image\22-数字证书工作流程.webp)

# 箭头函数和普通函数的区别

---

## 箭头函数比普通函数更简洁

+ 如果没有参数，直接写一个空括号即可

+ 如果只有一个参数，可以省去参数的括号

+ 如果有多个参数，用逗号分隔

+ 如果函数体的返回值只有一句，可以省略大括号

+ 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void，最常见的就是调用一个函数

  ```js
  let fn = () => void doseNotReturn();
  ```

## 箭头函数没有自己的this

+ 箭头函数不会创建自己的this，所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它定义时已经确定了，之后不会改变

## 箭头函数继承来的this指向永远不会改变

```js
var id = 'GLOBAL';
var obj = {
    id: 'OBJ',
    a: function() {
        console.log(this.id);
    },
    b: () => {
        console.log(this.id);
    }
};
obj.a();	// 'OBJ'
obj.b();	// 'GLOBAL'
new obj.a()	// undefined
new obj.b()	// Uncaught TypeError: obj.b is not a constructor
```

对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即使这个函数是作为对象obj的方法调用，this依旧指向Window对象

> 需要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中

## call()、apply()、bind()等方法不能改变箭头函数this的指向

```js
var id = 'GLOBAL';
let fun1 = () => {
    console.log(this.id);
};
fun1();					// 'GLOBAL'
fun1.call({id: 'OBJ'});		// 'GLOBAL'
fun1.apply({id: 'OBJ'});	// 'GLOBAL'
fun1.bind({id: 'OBJ'})();	// 'GLOBAL'
```

## 箭头函数不能作为构造函数使用

构造函数在new的步骤实际上第二步就是将函数中的this指向该对象，但是由于箭头函数没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用

## 箭头函数没有自己的arguments

箭头函数没有自己的arguments对象，在箭头函数中访问arguments实际上获得的是它外层函数的arguments值

## 箭头函数没有prototype

## 箭头函数不能用作Generator函数，不能使用yeild关键字

# TCP和UDP的区别

---

|              | UDP                                        | TCP                                                  |
| ------------ | ------------------------------------------ | ---------------------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                             |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                                     |
| 传输方式     | 面向报文                                   | 面向字节流                                           |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                           |
| 适用场景     | 适用于实时应用，例如视频会议、直播         | 适用于要求可靠传输的应用，例如文件传输               |

# GET和POST请求的区别

---

+ 应用场景：get请求是一个幂等的请求，一般get请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而post请求不是一个幂等的请求，一般用于对服务器资源产生影响的场景，比如注册用户这一类的操作
+ 是否缓存：因为应用场景的不同，浏览器一般会对get请求缓存，但很少对post请求缓存
+ 发送的报文格式：get请求的报文中实体部分为空，post请求的报文中实体部分一般为向服务器发送的数据
+ 安全性：get请求可以将请求的参数放入url中向服务器发送，这样的做法相对于post请求来说是不太安全的，因为请求的url会被保留在历史记录汇总
+ 请求长度：浏览器由于对url长度的限制，所以会影响get请求发送数据时的长度。这个限制是浏览器规定的，并不是RFC规定的
+ 参数类型：post的参数传递支持更多的数据类型

# JavaScript的数据类型

---

JavaScript中的基本数据类型可以分为两类：原始数据类型和引用数据类型

## 原始数据类型

原始数据类型的值是不可变的，并且是按值传递的，即变量存储的是实际的数据值

`String`、`Number`、`BigInt`、`Boolean`、`undefined`、`null`、`Symbol`

## 引用数据类型

引用数据类型的值是可变的，变量存储的是数据的引用地址，因此是按引用传递的

`Object`（包括`Array`、`Function`、`Date`、`RegExp`等）

+ Object：对象是由一组键值对组成的数据结构，用来存储各种类型的数据

  ```js
  let person = {
      name: 'John',
      age: 30
  };
  ```

+ Array：数据是一个有序的集合，可以存储多个值，支持按索引访问

  ```js
  let numbers = [1, 2, 3, 4, 5];
  ```

+ Function：函数也是一种对象，它是可以调用的代码块，通常用于封装代码逻辑

  ```js
  function greet(name) {
      return `Hello, ${name}!`;
  }
  ```

+ Date：表示日期和实践，提供了多种方法来处理时间

  ```js
  let today = new Date();
  ```

+ RegExp：用于处理文本模式匹配的对象，可以用来搜索和替换字符串

  ```js
  let regex = /ab+c/;
  ```

